<html>
<head>
<!DOCTYPE html>
<meta charset="utf-8">
<title>INFO 3300 PROJECT 2</title>
<script src="https://d3js.org/d3.v4.min.js"></script>
<script src="sankey.js"></script>

</head>
<style>

.node rect {
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  color: green;
  text-shadow: 0 1px 0 #fff;
}

.link {
  fill: none;
  stroke: #000;
  stroke-opacity: .2;
}

.link:hover {
  stroke-opacity: .5;
}

</style>
<body>

  <svg height="800" width="800">
  </svg>

  <script>

  var svg = d3.select("svg");
  var width = 600;
  var height = 600;

  var formatNumber = d3.format(",.0f"),
                        format = function(d) { return formatNumber(d) + " TWh"; },
                        color = d3.scaleOrdinal(d3.schemePastel1);

  // Set the sankey diagram properties
  var sankey = d3.sankey()
      .nodeWidth(10)
      .nodePadding(20)
      .size([width, height]);

  var path = sankey.link();

  var usaData;
  var gbData;
  var rawUsaData;
  var rawGbData;

  d3.queue()
  .defer(d3.csv, "USvideos.csv")
  .defer(d3.csv, "GBvideos.csv")
  .await(function(error, data1, data2) {
      if (error) {
          console.error('Error: ' + error);
      }
      else {
    	  console.log("start processing");
        rawUsaData = data1;
    	  rawGBData = data2;

    	  nestedUsaData = d3.nest()
    	  .key(function (d) { return d.category; })
    	  .entries(data1);

    	  nestedGBData = d3.nest()
    	  .key(function (d) { return d.category; })
    	  .entries(data2);

    	  console.log("done processing");

        //Probably insert interactivity if statements here on criteria:
        var criteria = "likes";

        UsaSummary = nestedUsaData.map(function (d) {
          return {
            Category: d.key,
            Value: d3.sum(d.values, d => d[criteria]),
            Max_name: d.values.sort(function(x, y){return d3.descending(x[criteria], y[criteria]);})[0].title,
            Max_value: d3.max(d.values, d => d[criteria])
          };
        });

        console.log(UsaSummary);

        GBSummary = nestedGBData.map(function (d) {
          return {
            Category: d.key,
            Value: d3.sum(d.values, d => d[criteria]),
            Max_name: d.values.sort(function(x, y){return d3.descending(x[criteria], y[criteria]);})[0].title,
            Max_value: d3.max(d.values, d => d[criteria])
          };
        });

        var nodes = ["USA", "GB"];
        var links = [];

        UsaSummary.forEach(function (d) {
          nodes.push(d.Category);
          links.push({ "source": "USA",
                       "target": d.Category,
                       "value": d.Value });
        });

        GBSummary.forEach(function (d) {
          if (!nodes.includes(d.Category)) {
            nodes.push(d.Category);
          }
          links.push({ "source": "GB",
                        "target": d.Category,
                        "value": d.Value });
        });

        links.forEach(function (d, i) {
           links[i].source = nodes.indexOf(links[i].source);
           links[i].target = nodes.indexOf(links[i].target);
        });

        nodes.forEach(function (d, i) {
          nodes[i] = { "name": d };
        });


        sankey
          .nodes(nodes)
          .links(links)
          .layout(12);

        var link = svg.append("g").selectAll(".link")
          .data(links)
          .enter().append("path")
          .attr("class", "link")
          .attr("d", path)
          .style("stroke-width", function(d) { return Math.max(1, d.dy); });

        link.append("title")
          .text(function(d) {
      		return d.source.name + " â†’ " +
                  d.target.name + "\n"
                  + format(d.value)
                  ; });

                  // add in the nodes
            var node = svg.append("g").selectAll(".node")
                .data(nodes)
              .enter().append("g")
                .attr("class", "node")
                .attr("transform", function(d) {
          		  return "translate(" + d.x + "," + d.y + ")"; })
              // .call(d3.behavior.drag()
              //   .origin(function(d) { return d; })
              //   .on("dragstart", function() {
          		//   this.parentNode.appendChild(this); })
              //   .on("drag", dragmove));

          // add the rectangles for the nodes
            node.append("rect")
                .attr("height", function(d) { return d.dy; })
                .attr("width", sankey.nodeWidth())
                .style("fill", function(d) {
          		  return d.color = color(d.name.replace(/ .*/, "")); })
                .style("stroke", function(d) {
          		  return d3.rgb(d.color).darker(2); })
              .append("title")
                .text(function(d) {
          		  return d.name + "\n"
                + format(d.value)
                ; });

          // add in the title for the nodes
            node.append("text")
                .attr("x", -6)
                .attr("y", function(d) { return d.dy / 2; })
                .attr("dy", ".35em")
                .attr("text-anchor", "end")
                .attr("transform", null)
                .text(function(d) { return d.name; })
              .filter(function(d) { return d.x > width / 2; })
                .attr("x", 6 + sankey.nodeWidth())
                .attr("text-anchor", "start");




      }
  });
  </script>
</body>
</html>
